\documentclass{egpubl}
\usepackage{vriphys2012}

% --- for  Annual CONFERENCE
% \ConferenceSubmission % uncomment for Conference submission
% \ConferencePaper      % uncomment for (final) Conference Paper
% \STAR                 % uncomment for STAR contribution
% \Tutorial             % uncomment for Tutorial contribution
% \ShortPresentation    % uncomment for (final) Short Conference Presentation
%
% --- for  CGF Journal
% \JournalSubmission    % uncomment for submission to Computer Graphics Forum
% \JournalPaper         % uncomment for final version of Journal Paper
%
% --- for  EG Workshop Proceedings
\WsSubmission    % uncomment for submission to EG Workshop
% \WsPaper         % uncomment for final version of EG Workshop contribution
%
 \electronicVersion % can be used both for the printed and electronic version

% !! *please* don't change anything above
% !! unless you REALLY know what you are doing
% ------------------------------------------------------------------------

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filename within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\PrintedOrElectronic

% prepare for electronic version of your document
\usepackage{t1enc,dfadobe}

\usepackage{egweblnk}
\usepackage{cite}

% For backwards compatibility to old LaTeX type font selection.
% Uncomment if your document adheres to LaTeX2e recommendations.
% \let\rm=\rmfamily    \let\sf=\sffamily    \let\tt=\ttfamily
% \let\it=\itshape     \let\sl=\slshape     \let\sc=\scshape
% \let\bf=\bfseries

% end of prologue

% ------------------------------------------------------------------------

\usepackage{ucs}
\usepackage[utf8x]{inputenc}

\usepackage{amsmath}

% Partial derivative
\newcommand{\deriv}[2]{\frac{\partial #1}{\partial #2}}

%\Figure{width}{name}{caption}
\newcommand{\Figure}[3]{%
\begin{figure}[htb]
  \centering
  \includegraphics[width=#1]{#2}
  \caption{\label{fig-#2}#3}
\end{figure}}

% For large/wide figures
%\FigureW{width}{name}{caption}
\newcommand{\FigureW}[3]{%
\begin{figure*}[htb]
  \centering
  \includegraphics[width=#1]{#2}
  \caption{\label{fig-#2}#3}
\end{figure*}}


%%% ADD COMMENTS=
\usepackage{color} 
\newcommand{\CD}[1]{{\color{magenta}{\textbf{C: #1}}}}


\title[Short title]%
      {Bezier shell finite element for interactive surgical simulation} % TODO

% for anonymous conference submission please enter your SUBMISSION ID
% instead of the author's name (and leave the affiliation blank) !!
\author[...]
       {...} % TODO

% ------------------------------------------------------------------------

% if the Editors-in-Chief have given you the data, you may uncomment
% the following five lines and insert it here
%
% \volume{27}   % the volume in which the issue will be published;
% \issue{1}     % the issue number of the publication
% \pStartPage{1}      % set starting page


%-------------------------------------------------------------------------
\begin{document}

% \teaser{
%  \includegraphics[width=\linewidth]{eg_new}
%  \centering
%   \caption{New EG Logo}
% \label{fig:teaser}
% }

\maketitle

\begin{abstract} % TODO
   The ABSTRACT is to be in fully-justified italicized text, 
   between two horizontal lines,
   in one-column format, 
   below the author and affiliation information. 
   Use the word ``Abstract'' as the title, in 9-point Times, boldface type, 
   left-aligned to the text, initially capitalized. 
   The abstract is to be in 9-point, single-spaced type.
   The abstract may be up to 3 inches (7.62 cm) long. \\
   Leave one blank line after the abstract, 
   then add the subject categories according to the ACM Classification Index 
   (see http://www.acm.org/class/1998/).

% TODO
\begin{classification} % according to http://www.acm.org/class/1998/
\CCScat{Computer Graphics}{I.3.3}{Picture/Image Generation}{Line and curve generation}
\end{classification}

\end{abstract}





%-------------------------------------------------------------------------

\section{Introduction} % {{{

Thin objects are very frequent in our every-day life. % thin wall objects ?
%Objects with thin structure occur in many forms 
e.g. textiles, paper, leaves etc. 
Such objects are also very common in anatomical or pathological structures for example tubular structures (like blood vessels, colon \ldots), thin bag structures (%vessie, 
Glisson capsule, aneurysms,  \ldots), and also many others (eyes, skin, \ldots). 
In the field of surgical simulation, we try to reproduce or anticipate the mechanical behavior of these structures during the surgery.
Thus, it is very important to capture accurately the physical behavior of these structure.
However, in the same time, it is also very important to maintain fast computation rates, in order to be compatible with the targeted applications (interactive simulation for education and for planning).

This problem has been faced by the computer graphics community but for different applications.
For instance, many related work addresses the problem of the simulation of cloth using mass-spring models \cite{Volino2009} or bending models \cite{Grinspun2003,Choi2007}. %% Todo verify.... 
However, these models are discrete so their behavior depends on the mesh and their parameters are not easily measurable.
This is completely acceptable for some computer graphics application, where the parameters can be tuned manually to obtain a realistic animation.
In the case of medical simulation, more physics-based modeling is needed.


Methods based on continuum mechanics and namely theory of elasticity gained on popularity in computer graphics and real-time simulators ever since Terzopoulos \cite{Terzopoulos1987} presented his work on elastic deformation modeling.  %% Do we
While the methods using finite elements and theory of elasticity are fairly popular in volumetric modeling \footnote{TODO: do we need ref. here?  yes but for medical applications} of deformations, they are still frowned upon in the area of thin structures. 
Yet, a special field of continuum mechanics has studied the deformations of these objects, and has proposed models based on shell theory.
This theory was integrated numerically \CD{Todo citation of a shell book} using Finite Elements, but there are two issues for obtaining interactive frame rates: 
(i) the continuum equations requires second spatial derivations that can not be handled with linear interpolation and 
(ii) the final system of equations that describes the mechanics is non-linear (if the deformations are not small).

The usual argument against non-linear FEM based methods is that they are computationally too expensive. 
This is indeed true if lots of elements are used to discretize the object.
A classical strategy, is to use high-polygonal meshes for rendering or collision detection and response, while maintaing a reasonably low number of elements for the mechanics.
The work of Bouthors et al.\cite{Bouthors2007} is a good application example of this strategy for surface deformations.
But this strategy is not sufficient in our case because the problem of performance is also greatly impacted when using elements that have an interpolation with high order polynoms.
This type of interpolation is necessary because bending continuum model
(based on Kirchhoff-Love theory for thin plates)  requires the computation of second spatial derivatives.
In \cite{Comas2010c}, Comas and al.  use an hybrid interpolation: linear interpolation is used for in-plane deformations and cubic polynomials for bending deformations.
The element is piloted by 3 nodes on which 6 degrees of freedom are defined. 
From this point of view, our work is derived from this approach but we address several noted drawbacks: the formulation misses one rotational degree of freedom, the cubic interpolation is not symmetric and produces $C^0$  discontinuities between elements on edges.
Ubach and al. \cite{Ubach2010}  present a shell element based on B\'ezier triangles that allows for a better behavior.
However, the B\'ezier interpolation defined on each triangle element is based on the motion computed on adjacent triangles.
So the stiffness forces computed on each element not only depends on nodes of the element but also on all the adjacent nodes. 
This greatly reduces the sparsity of the global stiffness matrix and consequently increases the computation time.


% TODO: paper structure
TODO: paper structure

\subsection{Contribution}

% TODO
The main contributions of the paper are following:
\begin{itemize}
    % not really novel, similar model already in Ubach2010
    %\item shell element based on Bézier triangles
    \item Our element solves the problems of the element presented by Comas
        \cite{Comas2010c}: it is continuous on the element boundary and has
        all rotational degrees of freedom.

    % TODO: needs better explanation
    \item Two stage interpolation: 6DOF nodes -> bezier points -> bezier
        triangle

    % + separation between nodes and dofs
    %\item The model separates nodes of the mesh from degrees of freedom of the
    %    control mesh. This allows mapping a surface on deformable skeleton.

    % + mapping: smooth surface results with less shells + collision response
    %   on smooth surface 
    \item Mapping of high resolution mesh on the curved surface of the
        shell. The smooth mapped surface can be used for collision
        detection and allows the propagation of proper collision response
        back onto the (low resolution) mechanical mesh.

\end{itemize}

% }}}


\section{Element kinematics} % {{{

\CD{intro: we propose an interpolation with a high degree of derivability while maintaining a reasonably low number of degrees of Freedom.
We introduce a new way of building the interpolation by using two stages: 
(i) a B\'ezier interpolation is defined with cubic polynomial functions 
(ii) a kinematic relation between nodes (6DOFs) defined at the vertices and the control points of the B\'ezier Triangle}

\subsection{B\'ezier Triangle Interpolation} % {{{

In the rest of the document we define the surface over the triangle:
\begin{equation}
    (\xi_1,\xi_2) \in \bigtriangleup = \left\{ (\xi_1,\xi_2)~|~\xi_1, \xi_2 \ge 0
        \mathrm{~and~} \xi_1+\xi_2 \le 1 \right\}
\end{equation}

B\'ezier triangles were designed in sixties by French mathematician de Casteljau.  % SURE ? What about Bezier himself ?
As with other B\'ezier or B-spline surfaces the B\'ezier triangle is
defined by a mesh of control points that do not necessarily lie on the
surface. The general $n$-th order B\'ezier triangle requires $(n + 1)(n +
2)/2$ control points and it's surface is defined as:

\begin{equation}
    T(\xi_1, \xi_2) = \sum_{0 \le i + j \le n} B^n_{i,j}(\xi_1,\xi_2) P_{i,j}
\end{equation}

\noindent
where $P_{i,j}$ are the control points and $B^n_{i,j}$ are the bivairate
Bernstein basis functions defined as:

\begin{equation}
  B^n_{i,j} (\xi_1,\xi_2) =
    \binom{n}{i~j} \xi_1^i \xi_2^j (1-\xi_1-\xi_2)^{n-i-j},
\end{equation}
\begin{equation}
  \binom{n}{i~j} = \frac{n!}{i!j!(n-i-j)!}
\end{equation}

\noindent
where $ 0 \le i+j \le n $.

In our work we use cubic B\'ezier triangle ($n=3$). Triangle of smaller order
would fail to describe all possible deformations of the element and
triangles of higher order cannot be described unambiguously with only 18
DOFs available to us without adding further constraints on the control
mesh. Cubic triangle is described by 10 control points and the surface is
explicitly defined as (see fig. \ref{fig-bezier}):

\begin{equation}\label{eq-cubicbez}
  \begin{split}
  T(\xi_1,\xi_2) & =
             \xi_1^3\ P_1
           + \xi_2^3\ P_2
           + \xi_3^3\ P_3 \\
         & + 3\ \xi_1^2 \xi_2\ P_4
           + 3\ \xi_1^2 \xi_3\ P_5
           + 3\ \xi_2^2 \xi_3\ P_6 \\
         & + 3\ \xi_1 \xi_2^2\ P_7
           + 3\ \xi_1 \xi_3^2\ P_8
           + 3\ \xi_2 \xi_3^2\ P_9 \\
         & + 6\ \xi_1 \xi_2 \xi_3\ P_{10} \\
  \end{split}
\end{equation}

\noindent
where $ \xi_3 = 1 - \xi_1 - \xi_2 $. By naming $n_i$ the respective values
of the Bernstein basis functions linked to control point $P_i$ we can
shortly express \eqref{eq-cubicbez} as:

\begin{equation}\label{eq-cubicbez2}
    T = \sum_{i=1}^{10} n_i P_i
\end{equation}

\Figure{0.8\linewidth}{bezier}
{Cubic B\'ezier triangle with mesh of 10 control points.}

% }}}

\subsection{Kinematic between Nodes and Control Points } % {{{

The B\'ezier triangles are defined by a mesh of control points, however the
simulated object is usually described by a triangular mesh with 6 degrees of freedom per node (position \& rotation).
%
\CD{I would not say that it is "usual"... => I would say that 10 points x 3 Dofs  = 30 Dofs for a bezier triangle $\rightarrow$ it's quite a lot ! 
We propose to reduce the degrees of freedom by using 3 nodes with 6 dofs = 18 Dofs }
%
We constructthe initial B\'ezier mesh by taking into account the curvature of the triangular
mesh. Note that special care has to be taken to maintain
the continuity across the nodes and edges. During the initialization phase
we partially employ the method described in \cite{Ubach2010} to maintain
$C^0$ continuity on the edges. Each of the control points on the edge is
computed as the intersection of (\CD{Need to do a figure of this}):

\begin{enumerate}
    \item The plane perpendicular to the normal at the vertex.
    \item The plane that contains the curve of triangle's contour. The
        choice is arbitrary, but necessary to maintain $C^0$ continuity. 
        We choose the plane defined by the edge of the flat triangle and
        average of the two normals at vertices of the edge. 
    \item The plane perpendicular to the edge of the flat triangle placed at
        $1/3$ of the edge length.
\end{enumerate}

Notice that the points on the edge will be same for both triangles sharing
the edge.

We do not repeat this procedure during the simulation. 
\CD{Why ?... do we argue that it is only for having fast update ?  } 
For fast update of
the control points we rigidly attach each edge point to nearest corner point (see Figure
\ref{fig-segments} for the correspondence between edge points and
associated corner points).

\Figure{0.8\linewidth}{segments}
{Correspondence between edge points and associated corner points shown in
blue. \CD{Not clear !!}}

In the initialization phase we remember the position of edge point relative to the position and orientation of the corner node:


\begin{equation}
    \overline{P_{i-j}} = (R_i^0)^T P_{i-j}^0
\end{equation}


\noindent
where $P_{i-j}^0 = P_j^0 - P_i^0$, with $j \in [4;10]$ being index of the edge node and $i \in [1;3]$ the index of associated corner node, is the segment at the beginning of the simulation and $R_i^0$ the orientation of node $P_i$.

In each step of the simulation we recompute the new position based on 
current orientation of the corner node:
\CD{Other possible explanation: we apply the rigid transformation of frame $i$ on control point $j$ }

\begin{equation}
    P_j = P_i + P_{i-j} = P_i + R_i \overline{P_{i-j}}
\end{equation}

\CD{To be consitent with what I write in following, we could introduce a notation for the dofs of the nodes:  $\mathbf{x}_i$ for the position and $\theta_i$ for the rotation of the node $i$
Then, the previous equation would be:
\begin{equation}
    P_j = \mathbf{x}_i + P_{i-j} = P_i + R(\theta_i) \overline{P_{i-j}}
\end{equation}
where $ R(\theta_i)$ is the rotation matrix for the angular position of node $i$...
}

\noindent
where $P_i$ is the current position of corner node and $R_i$ its orientation.

$C^1$ continuity on the edges can also be maintained if special care is taken
when computing the position of the central point (see \cite{Ubach2010}). 
For simplicity we compute the central point like this: 
\CD{Here it is not clear that with this formulation we do not maintain $C^1$ Continuity...}

\begin{equation}\label{eq-central}
    P_{10} = \frac{1}{3}(\sum_{i=4}^9 P_i - \sum_{i=1}^3 P_i)
\end{equation}

% TODO: explain the equation eq-central? would require an image

That way if the element is not flat the central point is slightly elevated
and not in the plane of other nodes thus keeping the curvature of the
element.

%}}}

\subsection{Deflection function} % {{{

% TODO: we need to justify how we decide to move the control points

\CD{It's more about derivatives of the kinematic relation, right ?} 

We recall the equation for central node \eqref{eq-central} and
considering how are the edge points of control mesh connected to corner points with
segments $P_{i-j}$:

\begin{equation}
    P_{i-j} = P_j - P_i, \quad j \in [4;9], i \in [1;3].
\end{equation}




We now add small variation to the position ($U_1, U_2, U_3$) and orientation ($\theta_1, \theta_2, \theta_3$) of corner nodes to the equation of the element \eqref{eq-cubicbez}:

\begin{equation}
    \begin{split}
        & n_1 (P_1 + U_1)
        + n_2 (P_2 + U_2)
        + n_3 (P_3 + U_3) \\
        & + n_4 (P_1 + U_1 + P_{1-4} + P_{1-4} \times \theta_1)
        + n_5 (P_1 + U_1 + P_{1-5} + P_{1-5} \times \theta_1) \\
        & + n_6 (P_2 + U_2 + P_{2-6} + P_{2-6} \times \theta_2)
        + n_7(P_2 + U_2 + P_{2-7} + P_{2-7} \times \theta_2) \\
        & + n_8 (P_3 + U_3 + P_{3-8} + P_{3-8} \times \theta_3)
        + n_9 (P_3 + U_3 + P_{3-9} + P_{3-9} \times \theta_3) \\
        & + n_{10} \frac{1}{3} \left(
        \sum_{j=4}^9 (P_i + U_i + P_{i-j} + P_{i-j} \times \theta_i) - \sum_{i=1}^3 (P_i + U_i)
        \right) \\
%
        & = 
    \sum_{i=1}^{10} n_i P_i
      + n_1 U_1
      + n_2 U_2
      + n_3 U_3 \\
      & + n_4 (U_1 + P_{1-4} \times \theta_1)
      + n_5 (U_1 + P_{1-5} \times \theta_1)
      + n_6 (U_2 + P_{2-6} \times \theta_2) \\
      & + n_7 (U_2 + P_{2-7} \times \theta_2)
      + n_8 (U_3 + P_{3-8} \times \theta_3)
      + n_9 (U_3 + P_{3-9} \times \theta_3) \\
      & + n_{10} \frac{1}{3} (U_1 + U_2 + U_3 + \sum_{j=4}^9 P_{i-j} \times \theta_i) \\
%
      & = T + U_1 (n_1 + n_4 + n_5 + \frac{1}{3} n_{10}) \\
      & + U_2 (n_2 + n_6 + n_7 + \frac{1}{3} n_{10}) \\
      & + U_3 (n_3 + n_8 + n_9 + \frac{1}{3} n_{10}) \\
      & + \sum_{j=4}^9 n_j P_{i-j} \times \theta_i
      + n_{10} \frac{1}{3} \sum_{j=4}^9 P_{i-j} \times \theta_i \\
%
      & = T + u
  \end{split}
\end{equation}



\CD{I would use the following notation: small variation of the node $j$ position:   $\delta \mathbf{x}_j$ for the translation and $\delta \boldsymbol{\theta}_j$ for the rotation.
This small variation of the position creates a small variation of the control points $i$ position $\delta P_i$ that are on the edges:
$$
\delta P_i =  \delta \mathbf{x}_j +  P_{i-j} \times \delta \boldsymbol{\theta}_j
$$
 Variation of node $10$ will be:
$$
\delta P_{10} =  \sum_{j=1}^3  \frac{1}{3}(\delta \mathbf{x}_j +  P_{10-i} \times \delta \boldsymbol{\theta}_i)
$$
%
Thus, finally, it will creates a variation of the point position on the surface $\delta T$...
$$
\delta T =   \sum_{i=1}^{10} n_i  \delta P_i
$$
which makes:
\begin{equation}
    \begin{split}
\delta T =  (n_1 + n_4 + n_5 + \frac{1}{3} n_{10})  \delta \mathbf{x}_1 \\
 + (n_2 + n_6 + n_7 + \frac{1}{3} n_{10})  \delta \mathbf{x}_2 \\
 + (n_3 + n_8 + n_9 + \frac{1}{3} n_{10})  \delta \mathbf{x}_3 \\
+  \sum_{i=4}^9  \sum_{j=1}^3 n_i P_{i-j} \times \delta \theta_j \\
 +  n_{10} \frac{1}{3} \sum_{j=1}^3 P_{10-j} \times \theta_j
  \end{split}
\end{equation}
%
}


\noindent
thus computing the function of deflection $u$ 
\CD{ or $\delta T$ }.

We have simplified the notation by leaving the variable $i$ free in the above sums involving $P_{i-j}$.
Note however that the expressions are sound and unambiguous because there is only one possible $i$ for each $j$ depending on the connection of segments to the corner nodes (see fig. \ref{fig-segments}).

% }}}

% }}}


\section{...} % {{{

\subsection{Shell Element}

Shell element is a combination of two simpler elements describing two types
of deformations:

\begin{itemize}

    \item Elastic membrane defining deformations in plane of the
    element. It encompasses deformations like stretching and shearing and
    is described by 3 degrees of freedom: in-plane displacements $u_x, u_y$
    and rotation $\theta_z$ around the axis perpendicular to the plane of
    the element (Figure \ref{fig-membrane}).

\Figure{0.8\linewidth}{membrane}
{DOFs of elastic membrane element.}


    \item Bending plate defining out of plane bending deformation. It is
    described by 3 degrees of freedom: rotation around two axes $\theta_x,
    \theta_z$ and out of plane displacement $u_z$ (Figure \ref{fig-plate}).

\end{itemize}

\Figure{0.8\linewidth}{plate}
{DOFs of bending plate element.}

Combining both elements we make use of all 6 degrees of freedom available
at each node of the element.


\subsection{Mechanics} % {{{

...

Using the plate theory we can now compute the strain-displacement matrices
from the displacement field. From the Cauchy's strain tensor for the
elastic membrane:

\begin{equation}\label{eq-cauchy}
    J_m = \left[ \begin{matrix}
        \deriv{u_x}{x} \\
        \deriv{u_y}{y} \\
        \deriv{u_x}{y} + \deriv{u_y}{x}
    \end{matrix} \right]
\end{equation}

\noindent
and from Kirchhoff-Love theory for thin plates:

\begin{equation}\label{eq-kirchhoff}
    J_b = \left[ \begin{matrix}
        - z \deriv{^2 u_z}{x^2} \\
        - z \deriv{^2 u_z}{y^2} \\
        - 2z \deriv{^2 u_z}{xy}
    \end{matrix} \right]
\end{equation}

Assuming constant thickness $t$ of the element and integrating over the volume
of the element we compute the stiffness matrices for the elastic membrane
and bending plate respectively:

\begin{align}
    \label{eq-Km}
    K_m & = \iiint_V J_m^T M J_m \, \mathrm{d} V \\
    \label{eq-Kb}
    K_b & = \iiint_V J_b^T M J_b \, \mathrm{d} V
\end{align}

\noindent
where $M$ is the material matrix. To keep the system simple we use linear
Hooke's law for isotropic materials.

Because the deformation field for the shell is non-linear \eqref{eq-bezU}
the integrals \eqref{eq-Km} and \eqref{eq-Kb} have to be computed using
numerical integration. In our implementation we employ 6-point Gaussian
quadrature for integration over triangle area.
% TODO: add ref
% TODO: add abscissas/weights?

% }}}

\subsection{Corotational Formulation} % {{{
\label{sec-corot}

It is known that the Cauchy's strain tensor \eqref{eq-cauchy} is not
rotation invariant \footnote{add ref} and produces ghost forces for rigid
rotations. The alternative approach is to use Green's strain tensor,
however it leads to nonlinear system. To keep the system linear and to deal
with rigid body rotations we compute the displacements and forces in
corotational frame. At each step of the simulation we compute the local
frame for every element, the resulting internal force of deformed element
is then computed relative to this frame:

\begin{equation}
    F_e = R_e^T (K_e u) = R_e^T \left(K_e(R_e x - R_e^0 x^0)\right)
\end{equation}

\noindent
where $R$ and $R_0$ are rotation matrices of the frame for current and rest
mesh respectively.

TODO: how we compute frame?
%from the position of the corner nodes and we align one axis of the frame with one
%edge of the element. \footnote{add image}


%The displacement field defined in \eqref{eq-bezU} is clearly symmetric in
%respect to deformations, but ...

This choice of the frame aligns one axis of the frame with one of the edges
of the triangle. Correct choice of the corotational frame is a tricky
problem \cite{Felippa2005} and incorrect frame for the membrane element can
have adverse effects on the simulation. In our case we have experienced
nonnegligible difference in deformation of equilateral triangle depending
on whether an axis was aligned to the edge favored by the deformation or to
one of the two other edges.

Performing a polar decomposition on the deformation gradient $F = \nabla u
+ I$ can be used to extract a rotation component from the deformation of
the element \cite{Ciarlet1994}. Because we are only fixing the membrane
element we can perform the polar decomposition in 2D with the following
formula:

\begin{equation}
    R = F + \mathrm{sgn}(\mathrm{det}(F)) \begin{pmatrix}
        F_{22} & - F_{21} \\
        F_{12} & F_{11}
    \end{pmatrix}
\end{equation}

\noindent
and subsequently normalizing the columns. We then rotate the corotational
frame in inverse direction. Even single step of this process improves the
final frame but more iterations of the polar decompositions are usually
necessary (up to 20) which severely degrades the performance. But polar
decomposition tends to "overshoot" the ideal rotation angle and each
subsequent step performs a rotation in the opposite direction. By properly
scaling the rotation angle we are able to minimize the amount of needed
iterations down to 5. The best value for the scaling factor depends on the
simulated problem, but we have experimentally localized the best value to
be somewhere between 0.6 and 0.65. We choose to use the value 0.61.

We employ two stop conditions for the iteration process:
\begin{itemize}
    \item The change in rotation angle is less than $10^{-6}$,
    \item and the maximum number of 5 iterations.
\end{itemize}

If the first condition is not met in 5 iterations it can mean one of three
things:

\begin{enumerate}
    \item We still have very good approximation of the ideal frame.
    \item The convergence for the element is too slow.
    \item The process is diverging.
\end{enumerate}

\noindent
and performing any more iterations is unnecessary.

% TODO: maybe make a short table showing the convergence to the symmetric
% solution.


% }}}

% }}}


\section{Visual and Mechanical Mapping} % {{{

Because of the bending property of the shells relatively few elements are
necessary to simulate curved surface. To enrich the visual experience from
the simulated object it is desirable to use more triangles in the areas
with high curvature during rendering. Besides the visual accuracy the high
resolution mesh correctly modeling the curved areas is needed for
interaction and correct simulation of collisions and constraints. To handle
these we have also to know how to map the velocities from the mechanical
mesh onto the high resolution mesh and how to map forces acting on the high
resolution mesh back onto the mechanical mesh.

\subsection{Mapping the Surface Mesh}

We use the fact that the geometry of the shell is based on the formulation
of cubic B\'ezier triangle \eqref{eq-cubicbez}. For every vertex of the high
resolution mesh we first find the corresponding triangle on the mechanical
mesh that is closest to the vertex and assign barycentric coordinates on
the triangle to this vertex. After every step of the simulation the high
resolution mesh is updated using the assigned barycentric coordinates and
the function of the surface \eqref{eq-cubicbez}.

\subsection{Mapping Velocities}

In the 

Differentiating \eqref{eq-cubicbez2} by time we get:

\begin{equation}
    \dot{T} = \sum_{i=1}^{10} n_i \dot{P_i} = \sum_{i=1}^{10} n_i V_i
\end{equation}

Which means we use the same expression to interpolate the velocities only
substituting the velocities at control points. For the corner nodes we
already have the velocities $V_i$. For the internal nodes we need to compute
them. In case of the edge nodes it is a problem of computing the velocity
of a point attached to the moving rigid body:

\begin{eqnarray}
    V_i = V_j + \omega_j \times (P_i - P_j)
\end{eqnarray}

where $j$ is the index of the corner node this edge node is attached to and
$\omega_j$ is the angular velocity at the node. For the central node we
again use the interpolation as in \eqref{eq-central}.

\subsection{Mapping Forces}

For physical interaction with the object one also requiers that the normal
forces applied on the high resolution mesh are trasmitted back as forces
and torques on the vertices of the mechanical mesh.

We compute the influence of force $F$ on the corners through all the
associated control points by the formula:

\begin{eqnarray}
    F_1 & = & F \sum_{i \in \{1,4,5\}} n_i + \frac{1}{3} F n_{10} \\
    F_2 & = & F \sum_{i \in \{2,6,7\}} n_i + \frac{1}{3} F n_{10} \\
    F_3 & = & F \sum_{i \in \{3,8,9\}} n_i + \frac{1}{3} F n_{10}
\end{eqnarray}

%\begin{eqnarray}
%    F_1 & = & F (n_1 + n_4 + n_5) + \frac{1}{3} F n_{10} \\
%    F_2 & = & F (n_2 + n_6 + n_7) + \frac{1}{3} F n_{10} \\
%    F_3 & = & F (n_3 + n_8 + n_9) + \frac{1}{3} F n_{10} \\
%\end{eqnarray}

Similarly we compute the torques applied through edge control points and
the central control points by:

\begin{gather}
    \begin{split}
        \theta_1 & = P_{1-4} \times (n_4 F) + P_{1-5} \times (n_5 F) + \\
        & + \frac{1}{3} (P_{1-4} + P_{1-5}) \times (n_{10} F)
    \end{split}
    \\
    \begin{split}
        \theta_2 & = P_{1-6} \times (n_6 F) + P_{1-7} \times (n_7 F) + \\
        & + \frac{1}{3} (P_{1-6} + P_{1-7}) \times (n_{10} F) \\
    \end{split}
    \\
    \begin{split}
        \theta_3 & = P_{1-8} \times (n_8 F) + P_{1-9} \times (n_9 F) + \\
        & + \frac{1}{3} (P_{1-8} + P_{1-9}) \times (n_{10} F) \\
    \end{split}
\end{gather}

%\begin{eqnarray}
%    \theta_1 & = & \sum_{i \in \{4,5\}} P_{1-i} \times (n_i F) \\
%    & + &\frac{1}{3} (P_{1-4} + P_{1-5}) \times (n_{10} F) \\
%    \theta_1 & = & \sum_{i \in \{6,7\}} P_{1-i} \times (n_i F) + \\
%    & + &\frac{1}{3} (P_{1-6} + P_{1-7}) \times (n_{10} F) \\
%    \theta_1 & = & \sum_{i \in \{8,9\}} P_{1-i} \times (n_i F) + \\
%    & + &\frac{1}{3} (P_{1-8} + P_{1-9}) \times (n_{10} F) \\
%\end{eqnarray}
%
%\begin{eqnarray}
%    \theta_1 & = & \sum_{i \in \{4,5\}} P_{1-i} \times (n_i F) +
%    \frac{1}{3} (P_{1-4} + P_{1-5}) \times (n_{10} F) \\
%    \theta_1 & = & \sum_{i \in \{6,7\}} P_{1-i} \times (n_i F) +
%    \frac{1}{3} (P_{1-6} + P_{1-7}) \times (n_{10} F) \\
%    \theta_1 & = & \sum_{i \in \{8,9\}} P_{1-i} \times (n_i F) +
%    \frac{1}{3} (P_{1-8} + P_{1-9}) \times (n_{10} F) \\
%\end{eqnarray}

% }}}

\section{Validation and Results} % {{{

% We cannot show results for simple plane in bending because the solution
% seems to converge to wrong value (but it converges! :)). Thus showing
% results for plain membrane deformations doesn't make sense (it would be
% inconsistent).

In next two subsections we present tests to validate the convergence of our
B\'ezier shell element. The results are compared with the shell element
composed of DKT element and optimal ANDES element \cite{Felippa2003}. The
last subsection presents evaluation of the computational complexity of our
solution.

\subsection{Roof Test}

To validate the results of the element we have performed a modified version
of a test known as Scordelis-Lo roof. It simulates a cylindrical roof under
self-weight. The geometry is defined by 80° cylindrical patch of length
$L=50$ and radius $r=25$ and thickness $t=0.25$ and is discretized into
mesh of NxN nodes. The physical parameters are $E = 4.32 \times 10^8$ and
$\nu = 0$. The roof is loaded with uniformly distributed load $q = 90$ per
unit area. The curved edges are clamped at both ends to avoid rigid body
movement. This the only difference from the original Scordelis-Lo roof test
where the edges are free to move in longitudinal direction. The Figure
\ref{fig-roof} shows the vertical displacement of midpoint on the free
edge.

\Figure{\linewidth}{roof}
{Convergence for modified Scordelis-Lo roof test of DKT+ANDES element and
our B\'ezier shell element.}


\subsection{Hemisphere Test}

Second performed test is a hemisphere with hole subjected to two opposing
forces at the base. The geometry is described by a hemisphere with radius
$r=10$ and thickness $t=0.04$ with 18° hole at the top and the geometry is
discretized into the grid of NxN nodes per quadrant. The physical
parameters are $E = 6.825 \times 10^7$ and $\nu = 0.3$. The hemisphere is
at it's base subjected to two opposing outwards forces and two opposing
inwards forces with magnitude $P = 4$. To avoid rigid body movement we have
constrained two opposite nodes at the top of the hemisphere. The radial
displacement for one point with applied load is shown in Figure
\ref{fig-hemisphere}.

\Figure{\linewidth}{hemisphere}
{Convergence for test on hemisphere with 18° hole for the DKT+ANDES element and
our B\'ezier shell element.}

\subsection{Computation Speed}

In figure \ref{fig-fps} we present performance of the element in terms of
frames per second. All tests were performed on machine equipped Dual-Core
AMD Opteron Processor 2218 and 3 GB of RAM and conjugate gradient solver
has been to solve the system. Our implementation is without optimizations
and isn't parallel, which means only single CPU core was used for the
simulation. The values reported are for the raw physical simulation with
and without the frame fixing method described in subsection
\ref{sec-corot}. We also present results including the mapping of
high-resolution mesh onto the mechanical mesh for visualisation purposes or
collisions.

\Figure{\linewidth}{fps}
{Performance in frames per seconds for different number of elements. Shows
values for element with frame fixing (B) method described in subsection
\ref{sec-corot} and without it (A), and with high-resolution mesh of 2048
(C) or 3200 (D) triangles mapped onto the mechanical mesh.}

We can see that the frame fixing technique is really fast and we are able
to simulate up to 1000 elements and still maintain visual refresh rate of
25 FPS. Our implementation of mechanical mapping clearly needs improving
because it consumes most of the computation time, but it is still able to
provide good results for more than 600 elements.

\subsection{Applications}

The presented element has been successfully implemented in SOFA framework
\cite{Faure2012} for real-time surgical simulations. It has been evaluated
on several applications.

% TODO: !!! When ANONYMISING do something with the citation !!!
One being a tool for pre-operative planning of corrective surgery of
congenital heart diseases in infants \cite{Kislinskiy2012}. The cardiac
surgery is a complicated process where several arterial vessels have to be
cut, patched and reconnected. The element has been used for to model
deformations of blood vessels after suturing and/or applying a artificial
patch. Figure \ref{fig-chd} presents a screenshots of the application
prototype.

\FigureW{0.75\linewidth}{chd}
{Screenshots of the simulation system prototype for different surgical
procedures used to repair a coarctation of an aortic arch. The screenshots
are enriched with overlay delineations.}

Another designed application is simulation of women reproductive organs
(vagaina/uterus/\ldots). 
The simulation is so as to evaluate
stress on a tissue during a birth.


% }}}

\section{Discussion and Limitations} % {{{

Currently, due to the technical decisions the element has two limitations.
The first limitation is that the element does not provide $C^1$ continuity
across edges. It is $C^1$ continuous at corners but only $C^0$ on the
edges. This may prove to be an issue for example if curvature needs to be
computed not only inside the element but also on the edges.

The second limitation is the choice of rigidly attached edge control
points. While it greatly simplifies the formulation the rigidity may cause
issues. In case of large compression of the element the results may be
unpredictable. This is however unlikely to occur because the element will
bend before reaching such configuration. It may, however, fail to maintain
even curvature of the surface if the element is subjected to large
stretching.

On the other hand the choices provide a good trade-off between continuity
and simplicity. Only $ 3 \times 6~\mathrm{DOFs} = 18~\mathrm{DOFs}$ are
necessary while the B\'ezier triangle has theoretically $ 10 \times
3~\mathrm{DOFs} = 30~\mathrm{DOFs}$. For complex elements with high number
of nodes the interconnection between nodes increases, especially on the
vertices where the size of nodes involved depends also on number of
neighbouring elements. By keeping the element simple the sparsity of
stiffness matrix is not violated.

% }}}

\subsection{Conclusion} % {{{

This paper presents new shell element with geometry and displacement
function based on the formulation of B\'ezier triangle. It fixes problems
of the previous model \cite{Comas2010c}, namely:

\begin{itemize}

    \item It is continuous on the edges and provides $C^1$ continuity in
    corners of the element. This is essential for good visual experience if
    high-resolution mesh is mapped on the mechanical mesh.

    \item Deformations of the element are symmetric. A method of improving
    the corotational frame to keep the deformation symmetric is also
    presented in the paper.

    \item TODO: anything else \ldots? % TODO

    % TODO: check this:
    % + Better conditioning (comparison between Comas model and ours in term of
    %   convergence of CG...) 

\end{itemize}

Because of the formulation of B\'ezier triangle that is intrinsically present
there is a clean and obvious way of mapping high-resolution mesh for
better visualisation. We also provide a mapping of forces and velocities
between simulation mesh and mechanical mesh for collision detection/response
and interaction with the mesh which are essential component for the surgical
simulator.

Finally examples showing the convergence to the optimal solution were also provided. 

% }}}

%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}

\bibliography{vriphys2012.bib}

\end{document}

% vim: fdm=marker
